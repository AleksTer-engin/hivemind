# ИДЕАЛЬНАЯ АРХИТЕКТУРА HIVEMIND

## 🧠 **Концепция**
HiveMind — распределённая система агентов искусственного интеллекта, взаимодействующих через событийную шину и использующих различные типы памяти (реляционную, графовую, векторную) для хранения знаний.

## 🏗️ **Целевая структура**
┌─────────────────────────────────────────────────────────────────┐
│ КЛИЕНТСКИЙ СЛОЙ │
│ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ │
│ │ Web UI │ │ API Client │ │ CLI Tool │ │
│ │ (hivemind-ui)│ │ (external) │ │ (internal) │ │
│ └──────┬───────┘ └──────┬───────┘ └──────┬───────┘ │
└─────────┼─────────────────┼─────────────────┼───────────────────┘
│ │ │
▼ ▼ ▼
┌─────────────────────────────────────────────────────────────────┐
│ ШЛЮЗ (API GATEWAY) │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ - Аутентификация │ │
│ │ - Роутинг │ │
│ │ - Rate limiting │ │
│ │ - Сбор метрик │ │
│ └───────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
│
┌─────────────────────┼─────────────────────┐
▼ ▼ ▼
┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────────┐
│ СЛОЙ ОБРАБОТКИ │ │ СЛОЙ ОБРАБОТКИ │ │ СЛОЙ ОБРАБОТКИ │
│ ┌───────────────┐ │ │ ┌───────────────┐ │ │ ┌───────────────┐ │
│ │ CLASSIFIER │ │ │ │ EMBEDDER │ │ │ │ LINKER │ │
│ │ (Python) │ │ │ │ (?) │ │ │ │ (?) │ │
│ └───────┬───────┘ │ │ └───────┬───────┘ │ │ └───────┬───────┘ │
└──────────┼──────────┘ └──────────┼──────────┘ └──────────┼──────────┘
│ │ │
└────────────────────────┼────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────────────────┐
│ СОБЫТИЙНАЯ ШИНА (NATS) │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ Каналы: │ │
│ │ - data.ingest │ │
│ │ - data.classified │ │
│ │ - data.embedded │ │
│ │ - data.linked │ │
│ │ - agent.heartbeat │ │
│ │ - agent.command │ │
│ └───────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
│
┌─────────────────────┼─────────────────────┐
▼ ▼ ▼
┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────────┐
│ СЛОЙ ПАМЯТИ │ │ СЛОЙ ПАМЯТИ │ │ СЛОЙ ПАМЯТИ │
│ ┌───────────────┐ │ │ ┌───────────────┐ │ │ ┌───────────────┐ │
│ │ POSTGRES │ │ │ │ NEO4J │ │ │ │ QDRANT │ │
│ │ (реляционная │ │ │ │ (графовая) │ │ │ │ (векторная) │ │
│ │ память) │ │ │ │ │ │ │ │ │ │
│ └───────────────┘ │ │ └───────────────┘ │ │ └───────────────┘ │
└─────────────────────┘ └─────────────────────┘ └─────────────────────┘
│
▼
┌─────────────────────────────────────────────────────────────────┐
│ КЭШ И ОЧЕРЕДИ (REDIS) │
│ - Кэш результатов │
│ - Очереди задач │
│ - Публика/подписка │
└─────────────────────────────────────────────────────────────────┘

text

## 🔄 **Потоки данных**

1. **Входные данные** → API Gateway → NATS (data.ingest)
2. **Классификация** → Classifier подписывается на data.ingest → публикует в data.classified
3. **Эмбеддинги** → Embedder подписывается на data.classified → публикует в data.embedded
4. **Линковка** → Linker подписывается на data.embedded → публикует в data.linked
5. **Сохранение** → Специальные служебные агенты сохраняют в соответствующие БД

## 🧩 **Принципы**

- **Гексагональная архитектура** — каждый сервис изолирован
- **Event-driven** — коммуникация через NATS
- **Масштабируемость** — каждый сервис может иметь несколько реплик
- **Наблюдаемость** — метрики, логи, трейсинг
- **Идемпотентность** — повторная обработка не меняет результат

## 🎯 **Критерии успеха**

1. Любой агент может быть добавлен без изменения других
2. Система выдерживает отказ любого компонента
3. Данные не теряются при сбоях
4. Время ответа < 100ms для 95% запросов
5. Полная наблюдаемость состояния системы
